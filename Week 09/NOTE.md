学习笔记

1.  

    HTML解析   parser模块文件拆分

   + 方便管理，把parser单独拆到文件中；
   + parser接受HTML文本作为参数，返回一棵DOM树；

   

2.  

   + 利用FSM实现HTML分析；有限状态机
   + 在HTML标准中已经规定了HTML状态；

    

3.  

   + 主要标签：开始标签、结束标签、自封闭标签；
   + 使用状态机分别判断输入的是那种符号；

    

4. 

   + 增加业务逻辑；
   + 添加token，标签的 结束状态提交token；

   

5. 

   + 属性值分为单引号、双引号、无引号写法；
   + 和处理标签类似，把属性加到token暂存；

   

6. 

   + 使用栈构建DOM树；

   + 开始标签时创建元素入栈，遇到结束标签出栈；

   + 自闭和标签看作是入栈之后立即出栈；

   + 任何元素的父元素是它入栈前的栈项；

     

   

7. 

   + 文本节点和自闭和标签的处理机制类似；
   + 多个文本节点是需要合并的；

   

8. 

   + 遇到style标签时，就将css规则保存起来；此部分代码添加到判断token.type =="endTag"部分，top.tagName === "style"就是说明找到了style部分的结束位置；

   +  使用  css.parse(text)将text文本转为ast（抽象语法树）

     

9. 

   + 在创建元素 之后 立即计算CSS；
   + 分析元素时候是假设所有CSS规则全部收集完毕的，因此body内部的样式代码还是要具体分析的；

   

10. 

    + 必须是知道所有父元素才能判断元素与规则是否匹配；
    + 从上一步骤中获取当前 元素的所有父元素；
    + 获得的和计算的父元素匹配的顺序是从内向外的；

    

11. 

    + 选择器也是向外排列；
    + 复杂选择器拆成针对单个元素的选择器，使用循环匹配父元素队列；

    

12. 

    + 根据选择器的类型和元素属性，计算是否与当前元素匹配；
    + 实现三种基本选择器，实际情况要处理更复杂的复合选择器；

    

13.  

     + 只要匹配成功就形成 computedStyle；

​    

14.  

     + CSS规则是根据specificity和后来优先规则覆盖；
+ specificity是 个四元组，越左边权重越高；
    + 一个CSS规则的specificity根据包含的简单选择器相加而成；

    ​          
    
    

